Derni√®re mise √† jour : 10 ao√ªt 2025.
Ce fichier regroupe tout le code Python relatif au **scraping d'images** et √† l'int√©gration **WooCommerce**.
Il contient le script principal, le gestionnaire de profils pour sauvegarder des s√©lecteurs CSS,
le suivi de l'historique des op√©rations et les widgets Qt qui orchestrent ces √©l√©ments :
- interface de scraping et gestion des profils,
- stockage temporaire des produits,
- g√©n√©ration de fiches produits WooCommerce,
- serveur Flask pour d√©clencher √† distance les op√©rations.
Le widget d'interface ``ImageScraperWidget`` charge les profils via ``profile_manager`` afin de d√©terminer quel s√©lecteur utiliser et enregistre chaque ex√©cution dans ``history``.

# image_scraper.py
import os
import re
import time
from pathlib import Path
from typing import List, Set
from urllib.parse import urljoin, urlparse, unquote
import unicodedata

import requests
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.remote.webelement import WebElement

DEFAULT_USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/124.0.0.0 Safari/537.36"
)


def _create_driver(user_agent: str = DEFAULT_USER_AGENT) -> webdriver.Chrome:
    options = Options()
    options.add_argument(f"--user-agent={user_agent}")
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.add_experimental_option("useAutomationExtension", False)
    driver = webdriver.Chrome(options=options)
    driver.execute_cdp_cmd(
        "Page.addScriptToEvaluateOnNewDocument",
        {
            "source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined});"
        },
    )
    return driver


def _scroll_page(driver: webdriver.Chrome, pause: float = 0.5) -> None:
    last_height = driver.execute_script("return document.body.scrollHeight")
    position = 0
    while position < last_height:
        position += 600
        driver.execute_script(f"window.scrollTo(0, {position});")
        time.sleep(pause)
        last_height = driver.execute_script("return document.body.scrollHeight")


def _simulate_slider_interaction(driver: webdriver.Chrome) -> None:
    try:
        dots = driver.find_elements(By.CSS_SELECTOR, ".flickity-page-dots .dot")
        for i, dot in enumerate(dots):
            driver.execute_script("arguments[0].click();", dot)
            print(f"üü° Clic sur le point {i+1}/{len(dots)}")
            time.sleep(1.2)
    except Exception as e:
        print(f"‚ö†Ô∏è Aucun slider d√©tect√© ou erreur : {e}")


def _extract_urls(driver: webdriver.Chrome, selector: str) -> List[str]:
    elements = driver.find_elements(By.CSS_SELECTOR, selector)
    urls: Set[str] = set()

    for el in elements:
        tag = el.tag_name.lower()

        # Si c'est une balise <a>, on essaie de r√©cup√©rer l'attribut href
        if tag == "a":
            href = el.get_attribute("href")
            if href and href.endswith((".jpg", ".jpeg", ".png", ".webp")):
                urls.add(href)
                continue

        # Si c'est une balise <img> ou autre avec data-photoswipe-src / src / data-src
        src = (
            el.get_attribute("data-photoswipe-src")
            or el.get_attribute("src")
            or el.get_attribute("data-src")
        )
        if src:
            if src.startswith("//"):
                src = "https:" + src
            elif src.startswith("/"):
                src = urljoin(driver.current_url, src)
        if src and not src.startswith("data:image"):
            urls.add(src)
            continue

        # V√©rifie aussi dans le style (cas d'image en background)
        style = el.get_attribute("style") or ""
        match = re.search(r"url\(['\"]?(.*?)['\"]?\)", style)
        if match:
            url = match.group(1)
            if not url.startswith("data:image"):
                urls.add(url)

    return list(urls)


def _download(url: str, folder: Path) -> None:
    if url.startswith("data:image"):
        print(f"\u26A0\uFE0F Ignor√© (image base64) : {url[:50]}...")
        return

    try:
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()

        # V√©rifie que la r√©ponse est bien une image
        content_type = resp.headers.get("Content-Type", "")
        if not content_type.startswith("image/"):
            print(f"\u274c Mauvais type de contenu pour {url}: {content_type}")
            return

        # Ignore les contenus vides ou trop petits pour √™tre une image r√©elle
        if not resp.content or len(resp.content) < 100:
            print(f"\u26A0\uFE0F R√©ponse vide ou suspecte pour {url}")
            return

    except Exception as exc:
        print(f"\u274c Erreur lors du t√©l√©chargement de {url}: {exc}")
        return

    # Enregistrement avec gestion de collision de nom
    name = os.path.basename(url.split("?")[0]) or "image"
    stem, ext = os.path.splitext(name)
    stem = re.sub(r"-\d+$", "", stem)
    name = f"{stem}{ext}"
    path = folder / name
    base, ext = os.path.splitext(path)
    idx = 1
    while path.exists():
        path = Path(f"{base}_{idx}{ext}")
        idx += 1
    with open(path, "wb") as f:
        f.write(resp.content)


def _folder_from_url(url: str) -> Path:
    """Return a folder name derived from ``url``.

    The last segment of the path is used, hyphens are replaced with spaces and
    unsafe characters are removed.
    """
    from urllib.parse import urlparse, unquote

    path = unquote(urlparse(url).path)
    name = Path(path).name.replace("-", " ")
    # keep alphanumeric characters, spaces and underscores only
    name = re.sub(r"[^\w\s]", "", name).strip()
    return Path(name or "images")


def scrape_images(
    page_url: str,
    selector: str,
    folder: str | Path = "images",
    *,
    keep_driver: bool = False,
) -> int | tuple[int, webdriver.Chrome]:
    """Download images from ``page_url`` into a subfolder of ``folder``.

    The subfolder name is derived from the URL's last path segment. When
    ``keep_driver`` is ``True``, the Selenium driver is returned alongside the
    image count and left open for further processing by the caller.
    """
    print("Chargement...")
    driver = _create_driver()
    try:
        driver.get(page_url)
        WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, selector))
        )
        _simulate_slider_interaction(driver)
        _scroll_page(driver)
        urls = _extract_urls(driver, selector)
        total = len(urls)
        if total == 0:
            print(
                "‚ö†Ô∏è Aucune image trouv√©e. V√©rifie si le slider charge bien dynamiquement."
            )
        else:
            print(f"{total} images trouv\u00e9es")
    finally:
        if not keep_driver:
            driver.quit()

    base_dir = Path(folder)
    images_dir = base_dir / _folder_from_url(page_url)
    images_dir.mkdir(parents=True, exist_ok=True)
    for i, url in enumerate(urls, 1):
        print(f"T\u00e9l\u00e9chargement de l'image n\u00b0{i}/{total}")
        _download(url, images_dir)
    print("\u2705 Termin\u00e9")

    if keep_driver:
        return total, driver
    return total


def scrape_variants(driver: webdriver.Chrome) -> dict[str, str]:
    """Extract product variant names and associated image URLs using ``driver``.

    ``driver`` must already be on the product page. Each variant input is
    expected inside the ``.variant-picker__option-values`` container.  The
    function clicks on each corresponding label, waits for the main product
    image to update and collects the resulting URL.
    """

    mapping: dict[str, str] = {}

    def _slugify(text: str) -> str:
        text = unicodedata.normalize('NFKD', text)
        text = text.encode('ascii', 'ignore').decode('ascii')
        text = re.sub(r"[^a-zA-Z0-9\s-]", "", text)
        text = re.sub(r"[\s_-]+", "-", text).strip("-")
        return text.lower()

    product_path = unquote(urlparse(driver.current_url).path).rstrip("/")
    product_name = Path(product_path).name
    product_slug = _slugify(product_name)

    def _img_url(el):
        return (
            el.get_attribute("src")
            or el.get_attribute("data-photoswipe-src")
            or el.get_attribute("data-src")
        )

    selectors = [
        ".woocommerce-product-gallery__image img",
        ".product-media img",
        ".product-image img",
        ".product-gallery img",
        ".product-main img",
    ]

    def _find_main_image() -> WebElement | None:
        for sel in selectors + ["img"]:
            try:
                img = driver.find_element(By.CSS_SELECTOR, sel)
                if img.is_displayed():
                    return img
            except Exception:
                continue
        return None

    try:
        inputs = driver.find_elements(
            By.CSS_SELECTOR, ".variant-picker__option-values input[type='radio']"
        )
        if not inputs:
            return mapping

        main_img = _find_main_image()
        if main_img is None:
            return mapping

        for inp in inputs:
            value = inp.get_attribute("value") or inp.get_attribute("data-value")
            input_id = inp.get_attribute("id")
            label = None
            if input_id:
                try:
                    label = driver.find_element(By.CSS_SELECTOR, f"label[for='{input_id}']")
                except Exception:
                    label = None
            if label is None:
                try:
                    label = inp.find_element(By.XPATH, "following-sibling::label[1]")
                except Exception:
                    continue

            previous = _img_url(main_img)
            driver.execute_script("arguments[0].click()", label)
            try:
                WebDriverWait(driver, 5).until(
                    lambda d: (_img_url(_find_main_image()) or "") != (previous or "")
                )
            except Exception:
                pass

            new_img = _find_main_image() or main_img
            main_img = new_img
            if value:
                variant_slug = _slugify(value)
                url = (
                    f"https://www.planetebob.fr/wp-content/uploads/2025/07/"
                    f"{product_slug}-{variant_slug}.jpg"
                )
                mapping[value] = url
    except Exception as exc:
        print(f"‚ö†Ô∏è Erreur lors du scraping des variantes: {exc}")

    return mapping


if __name__ == "__main__":
    scrape_images("https://exemple.com/produit", ".product-image img")

# profile_manager.py
import json
from pathlib import Path
from typing import List, Dict

# Path to the JSON file storing profiles. By default it is located at the
# project root but can be overridden in tests by changing this variable.
PROFILES_FILE = Path(__file__).resolve().parents[2] / "profiles.json"


def load_profiles() -> List[Dict[str, str]]:
    """Load scraping profiles from :data:`PROFILES_FILE`.

    Returns an empty list if the file does not exist or is empty.
    """
    if not PROFILES_FILE.exists():
        return []
    try:
        with open(PROFILES_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, list):
            return [p for p in data if isinstance(p, dict)]
    except Exception:
        pass
    return []


def save_profiles(profiles: List[Dict[str, str]]) -> None:
    """Write ``profiles`` to :data:`PROFILES_FILE` in JSON format."""
    with open(PROFILES_FILE, "w", encoding="utf-8") as f:
        json.dump(profiles, f, indent=2, ensure_ascii=False)


def add_profile(name: str, selector: str) -> None:
    """Add a new profile with ``name`` and ``selector``.

    Raises ``ValueError`` if a profile with the same name already exists.
    """
    profiles = load_profiles()
    if any(p.get("name") == name for p in profiles):
        raise ValueError(f"Profile '{name}' already exists")
    profiles.append({"name": name, "selector": selector})
    save_profiles(profiles)


def update_profile(name: str, selector: str) -> bool:
    """Update an existing profile's selector.

    Returns ``True`` if the profile was updated, ``False`` otherwise.
    """
    profiles = load_profiles()
    updated = False
    for profile in profiles:
        if profile.get("name") == name:
            profile["selector"] = selector
            updated = True
            break
    if updated:
        save_profiles(profiles)
    return updated


def delete_profile(name: str) -> bool:
    """Delete the profile with ``name``.

    Returns ``True`` if the profile was removed, ``False`` otherwise.
    """
    profiles = load_profiles()
    new_profiles = [p for p in profiles if p.get("name") != name]
    if len(new_profiles) == len(profiles):
        return False
    save_profiles(new_profiles)
    return True

# history.py
import json
from pathlib import Path
from datetime import datetime
from typing import List, Dict

# Path to the history log file at project root
HISTORY_FILE = Path(__file__).resolve().parents[2] / "scraping_history.json"

# Path to file storing last used url/folder
LAST_USED_FILE = Path(__file__).resolve().parents[2] / "scraping_last_used.json"


def _read_json(path: Path) -> List[Dict]:
    if not path.exists():
        return []
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f) or []
    except Exception:
        return []


def _write_json(path: Path, data) -> None:
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def log_scrape(url: str, profile: str, images: int, folder: str) -> None:
    """Append a scraping entry to :data:`HISTORY_FILE`."""
    entries = _read_json(HISTORY_FILE)
    entries.append(
        {
            "date": datetime.now().isoformat(timespec="seconds"),
            "url": url,
            "profile": profile,
            "images": images,
            "folder": folder,
        }
    )
    _write_json(HISTORY_FILE, entries)
    save_last_used(url, folder)


def load_history() -> List[Dict]:
    """Return the list of logged scraping entries."""
    return _read_json(HISTORY_FILE)


def save_last_used(url: str, folder: str) -> None:
    _write_json(LAST_USED_FILE, {"url": url, "folder": folder})


def load_last_used() -> Dict[str, str]:
    if not LAST_USED_FILE.exists():
        return {"url": "", "folder": ""}
    try:
        with open(LAST_USED_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, dict):
            return {"url": data.get("url", ""), "folder": data.get("folder", "")}
    except Exception:
        pass
    return {"url": "", "folder": ""}

# bus/event_bus.py
from PySide6.QtCore import QObject, Signal


class EventBus(QObject):
    profiles_changed = Signal()
    history_changed = Signal()


# singleton
bus = EventBus()

# widgets/profile_widget.py
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QListWidget,
    QLineEdit,
    QPushButton,
    QLabel,
)
from PySide6.QtCore import Signal, Slot, QTimer

from .. import profile_manager as pm
from ..bus.event_bus import bus


class ProfileWidget(QWidget):
    """Widget to manage scraping profiles."""

    profile_chosen = Signal(str)
    profiles_updated = Signal()

    def __init__(self) -> None:
        super().__init__()

        self.profile_list = QListWidget()
        self.profile_list.itemSelectionChanged.connect(self._on_profile_selected)

        self.name_edit = QLineEdit()
        self.selector_edit = QLineEdit()
        self.selector_edit.setText(
            ".woocommerce-product-gallery__image a"
        )

        self.add_btn = QPushButton("Ajouter")
        self.add_btn.clicked.connect(self._add_profile)
        self.update_btn = QPushButton("Modifier")
        self.update_btn.clicked.connect(self._update_profile)
        self.delete_btn = QPushButton("Supprimer")
        self.delete_btn.clicked.connect(self._delete_profile)

        form_layout = QVBoxLayout()
        form_layout.addWidget(QLabel("Nom:"))
        form_layout.addWidget(self.name_edit)
        form_layout.addWidget(QLabel("S√©lecteur CSS:"))
        form_layout.addWidget(self.selector_edit)

        btn_layout = QHBoxLayout()
        btn_layout.addWidget(self.add_btn)
        btn_layout.addWidget(self.update_btn)
        btn_layout.addWidget(self.delete_btn)

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Profils existants:"))
        layout.addWidget(self.profile_list)
        layout.addLayout(form_layout)
        layout.addLayout(btn_layout)

        self._load_profiles()

        # watch for external profile changes
        bus.profiles_changed.connect(self._load_profiles)

        self._mtime = (
            pm.PROFILES_FILE.stat().st_mtime if pm.PROFILES_FILE.exists() else 0
        )
        self._timer = QTimer(self)
        self._timer.setInterval(2500)
        self._timer.timeout.connect(self._check_profiles_file)
        self._timer.start()

    # ------------------------------------------------------------------
    def _load_profiles(self) -> None:
        """Load profiles from :mod:`profile_manager` and populate the list."""
        self.profiles = pm.load_profiles()
        self._refresh_list()

    def _refresh_list(self) -> None:
        self.profile_list.clear()
        for profile in self.profiles:
            self.profile_list.addItem(profile.get("name", ""))

    @Slot()
    def _on_profile_selected(self) -> None:
        current = self.profile_list.currentRow()
        if current < 0 or current >= len(self.profiles):
            return
        profile = self.profiles[current]
        self.name_edit.setText(profile.get("name", ""))
        self.selector_edit.setText(profile.get("selector", ""))
        self.profile_chosen.emit(profile.get("name", ""))

    @Slot()
    def _add_profile(self) -> None:
        name = self.name_edit.text().strip()
        selector = self.selector_edit.text().strip()
        if not name or not selector:
            return
        try:
            pm.add_profile(name, selector)
        except ValueError:
            return
        self._load_profiles()
        self.profiles_updated.emit()

    @Slot()
    def _update_profile(self) -> None:
        name = self.name_edit.text().strip()
        selector = self.selector_edit.text().strip()
        if not name or not selector:
            return
        if pm.update_profile(name, selector):
            self._load_profiles()

    @Slot()
    def _delete_profile(self) -> None:
        current = self.profile_list.currentRow()
        if current < 0 or current >= len(self.profiles):
            return
        name = self.profiles[current].get("name", "")
        if pm.delete_profile(name):
            self._load_profiles()
            self.profiles_updated.emit()

    # ------------------------------------------------------------------
    def _check_profiles_file(self) -> None:
        p = pm.PROFILES_FILE
        try:
            m = p.stat().st_mtime
            if m != self._mtime:
                self._mtime = m
                self._load_profiles()
        except Exception:
            pass


# widgets/image_widget.py
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QLabel,
    QPushButton,
    QTextEdit,
    QProgressBar,
    QLineEdit,
    QFileDialog,
    QHBoxLayout,
    QComboBox,
    QCheckBox,
    QApplication,
    QMessageBox,
)
from PySide6.QtCore import Qt, Slot
from PySide6.QtGui import QClipboard
from selenium.webdriver.common.by import By

import sys
from pathlib import Path


class _ConsoleStream:
    """File-like object writing text directly to a :class:`QTextEdit`."""

    def __init__(self, widget: QTextEdit) -> None:
        self.widget = widget

    def write(self, text: str) -> int:
        if text:
            # Qt widgets must be manipulated from the GUI thread. Using
            # ``append`` is safe enough for short text snippets.
            self.widget.append(text.rstrip())
        return len(text)

    def flush(self) -> None:  # pragma: no cover - required for file-like API
        pass

from .. import profile_manager as pm
from .. import history

from ..image_scraper import scrape_images, scrape_variants


class ImageScraperWidget(QWidget):
    """Simple interface to run the image scraper."""

    def __init__(self, *, storage_widget=None) -> None:
        super().__init__()

        self.storage_widget = storage_widget

        self.export_data: list[dict[str, str]] = []

        self.file_edit = QLineEdit()
        self.file_edit.setPlaceholderText("Fichier texte contenant les URLs")
        file_btn = QPushButton("Parcourir‚Ä¶")
        file_btn.clicked.connect(self._choose_file)

        file_layout = QHBoxLayout()
        file_layout.addWidget(self.file_edit)
        file_layout.addWidget(file_btn)

        self.profile_combo = QComboBox()
        self.profiles: list[dict[str, str]] = []
        self.selected_selector: str = ""
        self.profile_combo.currentIndexChanged.connect(self._on_profile_changed)

        self.folder_edit = QLineEdit()
        self.folder_edit.setPlaceholderText("Dossier de destination")

        browse_btn = QPushButton("Parcourir‚Ä¶")
        browse_btn.clicked.connect(self._choose_folder)

        folder_layout = QHBoxLayout()
        folder_layout.addWidget(self.folder_edit)
        folder_layout.addWidget(browse_btn)

        self.variants_checkbox = QCheckBox("Scraper aussi les variantes")

        self.start_btn = QPushButton("Lancer")
        self.start_btn.clicked.connect(self._start)
        self.copy_btn = QPushButton("Copier")
        self.copy_btn.clicked.connect(self._copy_console)
        self.export_btn = QPushButton("Exporter")
        self.export_btn.clicked.connect(self._export_excel)

        buttons_layout = QHBoxLayout()
        buttons_layout.addWidget(self.start_btn)
        buttons_layout.addWidget(self.copy_btn)
        buttons_layout.addWidget(self.export_btn)

        self.console = QTextEdit()
        self.console.setReadOnly(True)

        self.progress_bar = QProgressBar()
        self.progress_bar.hide()

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Fichier :"))
        layout.addLayout(file_layout)
        layout.addWidget(QLabel("Profil:"))
        layout.addWidget(self.profile_combo)
        layout.addWidget(QLabel("Dossier:"))
        layout.addLayout(folder_layout)
        layout.addWidget(self.variants_checkbox)
        layout.addLayout(buttons_layout)
        layout.addWidget(self.console)
        layout.addWidget(self.progress_bar)

        self.refresh_profiles()
        last = history.load_last_used()
        self.file_edit.setText(last.get("url", ""))
        self.folder_edit.setText(last.get("folder", ""))

    # ------------------------------------------------------------------
    def _on_profile_changed(self, index: int) -> None:
        if 0 <= index < len(self.profiles):
            self.selected_selector = self.profiles[index].get("selector", "")
        else:
            self.selected_selector = ""

    def set_selected_profile(self, profile: str) -> None:
        for i, p in enumerate(self.profiles):
            if p.get("name") == profile:
                self.profile_combo.setCurrentIndex(i)
                self.selected_selector = p.get("selector", "")
                return
        self.profile_combo.setCurrentIndex(-1)
        self.selected_selector = ""

    def refresh_profiles(self) -> None:
        self.profiles = pm.load_profiles()
        current = self.profile_combo.currentText()
        self.profile_combo.clear()
        for p in self.profiles:
            self.profile_combo.addItem(p.get("name", ""))
        # restore previous selection if possible
        if current:
            self.set_selected_profile(current)
        else:
            self._on_profile_changed(self.profile_combo.currentIndex())

    @Slot()
    def _choose_folder(self) -> None:
        path = QFileDialog.getExistingDirectory(self, "Choisir un dossier")
        if path:
            self.folder_edit.setText(path)

    @Slot()
    def _choose_file(self) -> None:
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Choisir un fichier",
            "",
            "Text Files (*.txt);;All Files (*)",
        )
        if path:
            self.file_edit.setText(path)

    @Slot()
    def _copy_console(self) -> None:
        """Copy the console's contents to the clipboard."""
        text = self.console.toPlainText()
        QApplication.clipboard().setText(text, mode=QClipboard.Clipboard)
        # Also populate the selection clipboard on platforms that support it.
        QApplication.clipboard().setText(text, mode=QClipboard.Selection)

    @Slot()
    def _export_excel(self) -> None:
        """Export scraped variant data to an Excel file."""
        if not self.export_data:
            QMessageBox.information(self, "Export", "Aucune donn√©e √† exporter.")
            return

        path, _ = QFileDialog.getSaveFileName(
            self,
            "Enregistrer sous",
            "",
            "Excel Files (*.xlsx)",
        )
        if not path:
            return

        try:
            from openpyxl import Workbook

            wb = Workbook()
            ws = wb.active
            ws.append(["URL", "Variante", "Image"])
            for row in self.export_data:
                ws.append([row["URL"], row["Variant"], row["Image"]])
            wb.save(path)
        except Exception as exc:
            QMessageBox.critical(self, "Export", f"Erreur: {exc}")
            return

        QMessageBox.information(self, "Export", "Export termin\u00e9.")

    @Slot()
    def _start(self) -> None:
        file_path = self.file_edit.text().strip()
        selector = self.selected_selector.strip()
        folder = self.folder_edit.text().strip() or "images"
        if not file_path or not selector:
            self.console.append("‚ùå Fichier ou s√©lecteur manquant")
            return

        path = Path(file_path)
        if not path.is_file():
            self.console.append("‚ùå Fichier introuvable")
            return

        try:
            with open(path, "r", encoding="utf-8") as f:
                urls = [line.strip() for line in f if line.strip()]
        except Exception as exc:
            self.console.append(f"‚ùå Erreur √† la lecture du fichier: {exc}")
            return

        if not urls:
            self.console.append("‚ùå Aucun URL dans le fichier")
            return

        self.start_btn.setEnabled(False)
        self.console.clear()
        self.progress_bar.show()
        self.progress_bar.setRange(0, 0)
        stream = _ConsoleStream(self.console)
        old_stdout = sys.stdout
        sys.stdout = stream
        self.export_data = []
        try:
            for url in urls:
                try:
                    if self.variants_checkbox.isChecked():
                        total, driver = scrape_images(
                            url, selector, folder, keep_driver=True
                        )
                        try:
                            product_name = driver.find_element(By.TAG_NAME, "h1").text.strip()
                        except Exception:
                            product_name = ""
                        variants = scrape_variants(driver)
                        if self.storage_widget:
                            self.storage_widget.add_product(product_name, list(variants.keys()))
                        driver.quit()
                    else:
                        total = scrape_images(url, selector, folder)
                        variants = {}
                except Exception as exc:
                    self.console.append(f"‚ùå Erreur sur {url}: {exc}")
                else:
                    self.console.append(f"‚úÖ {url} - {total} images")
                    for name, img in variants.items():
                        self.console.append(f"  ‚Ä¢ {name}: {img}")
                        self.export_data.append({"URL": url, "Variant": name, "Image": img})
                    history.log_scrape(url, self.profile_combo.currentText(), total, folder)
        finally:
            sys.stdout = old_stdout
            self.progress_bar.hide()
            self.start_btn.setEnabled(True)



# widgets/storage_widget.py
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
)
from PySide6.QtCore import Slot


class StorageWidget(QWidget):
    """Simple table to store scraped product names and variants."""

    HEADERS = ["Nom du produit", "Variantes"]

    def __init__(self) -> None:
        super().__init__()
        self.table = QTableWidget(0, len(self.HEADERS))
        self.table.setHorizontalHeaderLabels(self.HEADERS)

        self.clear_btn = QPushButton("Vider le stockage")
        self.clear_btn.clicked.connect(self.clear)

        layout = QVBoxLayout(self)
        layout.addWidget(self.table)
        layout.addWidget(self.clear_btn)

    # ------------------------------------------------------------------
    def add_product(self, name: str, variants: list[str]) -> None:
        row = self.table.rowCount()
        self.table.insertRow(row)
        self.table.setItem(row, 0, QTableWidgetItem(name))
        self.table.setItem(row, 1, QTableWidgetItem(", ".join(variants)))

    def get_products(self) -> list[dict[str, list[str]]]:
        products: list[dict[str, list[str]]] = []
        for row in range(self.table.rowCount()):
            name_item = self.table.item(row, 0)
            variants_item = self.table.item(row, 1)
            name = name_item.text() if name_item else ""
            variants_text = variants_item.text() if variants_item else ""
            variants = [v.strip() for v in variants_text.split(",") if v.strip()]
            products.append({"name": name, "variants": variants})
        return products

    @Slot()
    def clear(self) -> None:
        self.table.setRowCount(0)

# widgets/woocommerce_widget.py
from __future__ import annotations

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QFileDialog,
    QAbstractItemView,
    QCheckBox,
)
from PySide6.QtCore import Slot
import csv
import random
import string
import re
import unicodedata
from pathlib import Path
import requests


class WooCommerceProductWidget(QWidget):
    """Widget to edit WooCommerce product data in a table."""

    HEADERS = [
        "ID",
        "Type",
        "SKU",
        "Name",
        "Published",
        "Short description",
        "Description",
        "Regular price",
        "Sale price",
        "Categories",
        "Tags",
        "Images",
        "In stock?",
        "Stock",
        "Tax status",
        "Shipping class",
        "Attribute 1 name",
        "Attribute 1 value(s)",
        "Attribute 1 visible",
        "Attribute 1 global",
    ]

    # Folder containing downloaded product images. Tests monkeypatch this path.
    IMAGES_ROOT = Path("images")

    # Base URL for uploaded WooCommerce images.
    BASE_IMAGE_URL = "https://www.planetebob.fr/wp-content/uploads/2025/07/"

    @staticmethod
    def _slugify(text: str) -> str:
        text = unicodedata.normalize("NFKD", text)
        text = text.encode("ascii", "ignore").decode("ascii")
        text = re.sub(r"[^a-zA-Z0-9\s-]", "", text)
        text = re.sub(r"[\s_-]+", "-", text).strip("-")
        return text.lower()

    @staticmethod
    def _clean_image_urls(urls: list[str]) -> list[str]:
        """Remove duplicate image URLs using exact and prefix based checks."""
        # Remove exact duplicates first
        unique_urls = list(set(urls))

        prefix_set: set[str] = set()
        final_images: list[str] = []

        for url in sorted(unique_urls):
            filename = url.split("/")[-1]
            prefix = filename.split("_")[0].split("-56cm")[0]

            if prefix not in prefix_set:
                final_images.append(url)
                prefix_set.add(prefix)

        return final_images

    def __init__(self, *, storage_widget=None) -> None:
        super().__init__()
        self.storage_widget = storage_widget
        self.table = QTableWidget(0, len(self.HEADERS))
        self.table.setHorizontalHeaderLabels(self.HEADERS)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)

        add_btn = QPushButton("Ajouter une ligne")
        del_btn = QPushButton("Supprimer la ligne s√©lectionn√©e")
        fill_btn = QPushButton("Remplir")
        check_btn = QPushButton("V√©rifier URLs")
        import_btn = QPushButton("Importer CSV")
        export_btn = QPushButton("Exporter CSV")

        add_btn.clicked.connect(self.add_row)
        del_btn.clicked.connect(self.delete_selected_row)
        fill_btn.clicked.connect(self.fill_from_storage)
        check_btn.clicked.connect(self.check_urls)
        import_btn.clicked.connect(self.import_csv)
        export_btn.clicked.connect(self.export_csv)

        btn_layout = QHBoxLayout()
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(del_btn)
        btn_layout.addWidget(fill_btn)
        btn_layout.addWidget(check_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(import_btn)
        btn_layout.addWidget(export_btn)

        self.clean_images_checkbox = QCheckBox("Nettoyer les images dupliqu√©es")
        self.clean_images_checkbox.setChecked(True)

        layout = QVBoxLayout(self)
        layout.addLayout(btn_layout)
        layout.addWidget(self.clean_images_checkbox)
        layout.addWidget(self.table)

    # ------------------------------------------------------------------
    @Slot()
    def add_row(self) -> None:
        row = self.table.rowCount()
        self.table.insertRow(row)
        for col in range(self.table.columnCount()):
            self.table.setItem(row, col, QTableWidgetItem(""))

    @Slot()
    def delete_selected_row(self) -> None:
        row = self.table.currentRow()
        if row >= 0:
            self.table.removeRow(row)

    @Slot()
    def import_csv(self) -> None:
        path, _ = QFileDialog.getOpenFileName(
            self, "Importer CSV", "", "CSV Files (*.csv);;All Files (*)"
        )
        if not path:
            return
        try:
            with open(path, newline="", encoding="utf-8") as f:
                reader = csv.reader(f, delimiter="\t")
                rows = list(reader)
        except Exception:
            return
        if not rows:
            return
        start = 1 if rows[0][: len(self.HEADERS)] == self.HEADERS else 0
        for data in rows[start:]:
            row = self.table.rowCount()
            self.table.insertRow(row)
            for col in range(len(self.HEADERS)):
                value = data[col] if col < len(data) else ""
                self.table.setItem(row, col, QTableWidgetItem(value))

    @Slot()
    def export_csv(self) -> None:
        path, _ = QFileDialog.getSaveFileName(
            self, "Exporter CSV", "", "CSV Files (*.csv);;All Files (*)"
        )
        if not path:
            return
        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f, delimiter=";")
            writer.writerow(self.HEADERS)
            for row in range(self.table.rowCount()):
                data = []
                for col in range(self.table.columnCount()):
                    item = self.table.item(row, col)
                    data.append(item.text() if item else "")
                writer.writerow(data)

    @Slot()
    def check_urls(self) -> None:
        """Check that image URLs in the table are reachable and export a CSV."""
        path, _ = QFileDialog.getSaveFileName(
            self, "Exporter r√©sultat", "", "CSV Files (*.csv);;All Files (*)"
        )
        if not path:
            return

        img_col = self.HEADERS.index("Images")
        urls: list[str] = []
        for row in range(self.table.rowCount()):
            item = self.table.item(row, img_col)
            if not item:
                continue
            urls.extend(u.strip() for u in item.text().split(", ") if u.strip())

        results: list[tuple[str, str]] = []
        for url in urls:
            try:
                resp = requests.head(url, timeout=5)
                ok = resp.status_code == 200
            except Exception:
                ok = False
            results.append((url, "oui" if ok else "non"))

        with open(path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f, delimiter=";")
            writer.writerow(["URL", "OK"])
            writer.writerows(results)

    # ------------------------------------------------------------------
    @Slot()
    def fill_from_storage(self) -> None:
        """Create new rows from the linked storage widget."""
        if not self.storage_widget:
            return
        products = self.storage_widget.get_products()
        # Clear any previously populated rows before filling again so
        # repeated calls don't accumulate duplicates.
        self.table.setRowCount(0)
        type_col = self.HEADERS.index("Type")
        sku_col = self.HEADERS.index("SKU")
        name_col = self.HEADERS.index("Name")
        img_col = self.HEADERS.index("Images")

        used_skus: set[str] = set()

        def _gen_sku() -> str:
            """Generate a unique random SKU."""
            while True:
                sku = "SKU-" + "".join(
                    random.choices(string.ascii_uppercase + string.digits, k=8)
                )
                if sku not in used_skus:
                    used_skus.add(sku)
                    return sku

        for prod in products:
            product_name = prod["name"]
            variants = prod["variants"]
            product_slug = self._slugify(product_name)
            folder = self.IMAGES_ROOT / product_name
            local_images: list[str] = []
            if folder.is_dir():
                for p in sorted(folder.iterdir()):
                    if p.suffix.lower() in {".webp", ".jpg", ".jpeg", ".png"}:
                        local_images.append(p.name)

            variant_files = [
                f"{product_slug}-{self._slugify(v)}.jpg" for v in variants
            ]
            generic_images = [img for img in local_images if img not in variant_files]

            is_variable = len(variants) > 1

            if is_variable:
                row = self.table.rowCount()
                self.table.insertRow(row)
                for col in range(self.table.columnCount()):
                    self.table.setItem(row, col, QTableWidgetItem(""))

                parent_sku = _gen_sku()
                self.table.setItem(row, type_col, QTableWidgetItem("variable"))
                self.table.setItem(row, sku_col, QTableWidgetItem(parent_sku))
                self.table.setItem(row, name_col, QTableWidgetItem(product_name))
                parent_images = [
                    self.BASE_IMAGE_URL + img for img in generic_images + variant_files
                ]
                if self.clean_images_checkbox.isChecked():
                    parent_images = self._clean_image_urls(parent_images)
                if parent_images:
                    self.table.setItem(
                        row,
                        img_col,
                        QTableWidgetItem(", ".join(parent_images)),
                    )

                current_row = row
                for variant in variants:
                    current_row += 1
                    self.table.insertRow(current_row)
                    for c in range(self.table.columnCount()):
                        self.table.setItem(current_row, c, QTableWidgetItem(""))
                    self.table.setItem(current_row, type_col, QTableWidgetItem("variation"))
                    var_slug = self._slugify(variant)
                    sku_var = f"{parent_sku}-{var_slug}"
                    used_skus.add(sku_var)
                    name_var = f"{product_name} {variant}"
                    self.table.setItem(current_row, sku_col, QTableWidgetItem(sku_var))
                    self.table.setItem(current_row, name_col, QTableWidgetItem(name_var))
                    var_img = self.BASE_IMAGE_URL + f"{product_slug}-{var_slug}.jpg"
                self.table.setItem(current_row, img_col, QTableWidgetItem(var_img))
            else:
                row = self.table.rowCount()
                self.table.insertRow(row)
                for col in range(self.table.columnCount()):
                    self.table.setItem(row, col, QTableWidgetItem(""))

                sku_val = _gen_sku()
                self.table.setItem(row, type_col, QTableWidgetItem("simple"))
                self.table.setItem(row, sku_col, QTableWidgetItem(sku_val))
                self.table.setItem(row, name_col, QTableWidgetItem(product_name))
                images = [self.BASE_IMAGE_URL + img for img in generic_images + variant_files]
                if self.clean_images_checkbox.isChecked():
                    images = self._clean_image_urls(images)
                if images:
                    self.table.setItem(
                        row,
                        img_col,
                        QTableWidgetItem(", ".join(images)),
                    )



# widgets/flask_server_widget.py
from __future__ import annotations

"""Widget de contr√¥le pour :class:`FlaskBridgeServer`."""

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QCheckBox,
    QTextEdit,
    QApplication,
)
from PySide6.QtCore import Slot
import json
import os
import secrets

from ..server.flask_server import FlaskBridgeServer

CFG_FILE = "server_config.json"


class FlaskServerWidget(QWidget):
    """Interface graphique minimaliste pour d√©marrer le serveur Flask."""

    def __init__(self) -> None:
        super().__init__()
        self.server = FlaskBridgeServer(on_log=self._append)
        self._build_ui()
        self._load_cfg()

    # ------------------------------------------------------------------
    def _build_ui(self) -> None:
        self.port = QLineEdit("5001")
        self.api_key = QLineEdit(os.getenv("SCRAPER_API_KEY", ""))
        gen = QPushButton("G√©n√©rer")
        gen.clicked.connect(self._gen_key)
        self.expose = QCheckBox("Expose via ngrok")
        self.ngrok_token = QLineEdit(os.getenv("NGROK_AUTHTOKEN", ""))
        self.ngrok_token.setEchoMode(QLineEdit.Password)
        self.headless = QCheckBox("Headless par d√©faut")
        self.headless.setChecked(True)
        self.ignore_robots = QCheckBox("Ignorer robots.txt par d√©faut")
        self.rate = QLineEdit("0")
        self.maxw = QLineEdit("1")

        self.start = QPushButton("D√©marrer")
        self.stop = QPushButton("Arr√™ter")
        self.stop.setEnabled(False)
        self.url_label = QLabel("URL publique : (non expos√©)")
        self.status_label = QLabel("Statut : Arr√™t√©")
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        copyurl = QPushButton("Copier URL")
        copyurl.clicked.connect(self._copy_url)

        # layouts
        top = QHBoxLayout()
        top.addWidget(QLabel("Port:"))
        top.addWidget(self.port)

        k = QHBoxLayout()
        k.addWidget(QLabel("API Key:"))
        k.addWidget(self.api_key)
        k.addWidget(gen)

        n = QHBoxLayout()
        n.addWidget(self.expose)
        n.addWidget(QLabel("Ngrok token:"))
        n.addWidget(self.ngrok_token)

        o = QHBoxLayout()
        o.addWidget(self.headless)
        o.addWidget(self.ignore_robots)

        r = QHBoxLayout()
        r.addWidget(QLabel("Rate (img/min):"))
        r.addWidget(self.rate)
        r.addWidget(QLabel("Max workers:"))
        r.addWidget(self.maxw)

        btn = QHBoxLayout()
        btn.addWidget(self.start)
        btn.addWidget(self.stop)
        btn.addWidget(copyurl)

        lay = QVBoxLayout(self)
        for row in (top, k, n, o, r, btn):
            lay.addLayout(row)
        lay.addWidget(self.status_label)
        lay.addWidget(self.url_label)
        lay.addWidget(self.console)

        self.start.clicked.connect(self._start)
        self.stop.clicked.connect(self._stop)

    # ------------------------------------------------------------------
    def _append(self, text: str) -> None:
        self.console.append(text)

    def _gen_key(self) -> None:
        self.api_key.setText(secrets.token_urlsafe(24))

    def _copy_url(self) -> None:
        QApplication.clipboard().setText(
            self.url_label.text().replace("URL publique : ", "")
        )

    # ------------------------------------------------------------------
    def _load_cfg(self) -> None:
        try:
            if os.path.exists(CFG_FILE):
                with open(CFG_FILE, "r", encoding="utf-8") as f:
                    cfg = json.load(f)
                self.port.setText(str(cfg.get("port", 5001)))
                self.api_key.setText(cfg.get("api_key", ""))
                self.expose.setChecked(bool(cfg.get("expose", False)))
                self.ngrok_token.setText(cfg.get("ngrok_token", ""))
                self.headless.setChecked(bool(cfg.get("headless", True)))
                self.ignore_robots.setChecked(bool(cfg.get("ignore_robots", False)))
                self.rate.setText(str(cfg.get("rate", 0)))
                self.maxw.setText(str(cfg.get("max_workers", 1)))
        except Exception:
            pass

    def _save_cfg(self) -> dict:
        cfg = {
            "port": int(self.port.text() or 5001),
            "api_key": self.api_key.text().strip(),
            "expose": self.expose.isChecked(),
            "ngrok_token": self.ngrok_token.text().strip(),
            "headless": self.headless.isChecked(),
            "ignore_robots": self.ignore_robots.isChecked(),
            "rate": int(self.rate.text() or 0),
            "max_workers": int(self.maxw.text() or 1),
        }
        with open(CFG_FILE, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2, ensure_ascii=False)
        return cfg

    # ------------------------------------------------------------------
    @Slot()
    def _start(self) -> None:
        cfg = self._save_cfg()
        try:
            self.server.start(
                port=cfg["port"],
                api_key=cfg["api_key"],
                headless_default=cfg["headless"],
                user_agent=None,
                ignore_robots_default=cfg["ignore_robots"],
                rate_limit=cfg["rate"],
                max_workers=cfg["max_workers"],
            )
            pub = ""
            if cfg["expose"]:
                pub = self.server.enable_ngrok(cfg["ngrok_token"], cfg["port"])
            self.status_label.setText("Statut : En cours d‚Äôex√©cution")
            self.url_label.setText(
                f"URL publique : {pub or f'http://localhost:{cfg['port']}/health'}"
            )
            self.start.setEnabled(False)
            self.stop.setEnabled(True)
            self._append("üöÄ Serveur d√©marr√©")
        except Exception as e:  # pragma: no cover - UI feedback
            self._append(f"‚ùå Erreur d√©marrage : {e}")

    @Slot()
    def _stop(self) -> None:
        try:
            self.server.stop()
            self.status_label.setText("Statut : Arr√™t√©")
            self.url_label.setText("URL publique : (non expos√©)")
            self.start.setEnabled(True)
            self.stop.setEnabled(False)
            self._append("üõë Serveur arr√™t√©")
        except Exception as e:  # pragma: no cover - UI feedback
            self._append(f"‚ùå Erreur arr√™t : {e}")

# widgets/history_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QPushButton
from PySide6.QtCore import Slot

from .. import history


class HistoryWidget(QWidget):
    """Display previous scraping runs."""

    def __init__(self) -> None:
        super().__init__()
        self.text = QTextEdit(readOnly=True)
        self.refresh_btn = QPushButton("Rafra√Æchir")
        self.refresh_btn.clicked.connect(self.refresh)

        layout = QVBoxLayout(self)
        layout.addWidget(self.text)
        layout.addWidget(self.refresh_btn)

        self.refresh()

    @Slot()
    def refresh(self) -> None:
        entries = history.load_history()
        lines = []
        for entry in entries:
            lines.append(
                f"{entry.get('date','')} - {entry.get('url','')} ("\
                f"{entry.get('profile','')} - {entry.get('images',0)} images)"
            )
        self.text.setPlainText("\n".join(lines))

# widgets/settings_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout
from PySide6.QtCore import Signal


class ScrapingSettingsWidget(QWidget):
    module_toggled = Signal(str, bool)
    rename_toggled = Signal(bool)

    def __init__(self, modules_order=None):
        super().__init__()
        layout = QVBoxLayout(self)
        (modules_order or [])



# widgets/scrap_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QTabWidget

from .image_widget import ImageScraperWidget
from .history_widget import HistoryWidget
from .woocommerce_widget import WooCommerceProductWidget
from .storage_widget import StorageWidget
from .flask_server_widget import FlaskServerWidget


class _DummySubWidget(QWidget):
    def __init__(self) -> None:
        super().__init__()
        layout = QVBoxLayout(self)

    def set_selected_profile(self, profile: str) -> None:
        pass

    def refresh_profiles(self) -> None:
        pass


class ScrapWidget(QWidget):
    def __init__(self) -> None:
        super().__init__()
        self.modules_order = [
            "images",
            "combined",
            "flask",
            "history",
            "woocommerce",
            "stockage",
        ]
        self.storage_widget = StorageWidget()
        self.images_widget = ImageScraperWidget(storage_widget=self.storage_widget)
        self.combined_widget = _DummySubWidget()
        self.flask_widget = FlaskServerWidget()
        self.history_widget = HistoryWidget()
        self.woocommerce_widget = WooCommerceProductWidget(
            storage_widget=self.storage_widget
        )
        self.tabs = QTabWidget()
        self.tabs.addTab(self.images_widget, "Images")
        self.tabs.addTab(self.combined_widget, "Combined")
        self.tabs.addTab(self.flask_widget, "Serveur Flask")
        self.tabs.addTab(self.history_widget, "Historique")
        self.tabs.addTab(self.woocommerce_widget, "Fiche Produit WooCommerce")
        self.tabs.addTab(self.storage_widget, "Stockage")
        layout = QVBoxLayout(self)
        layout.addWidget(self.tabs)

    def toggle_module(self, name: str, enabled: bool) -> None:
        pass

    def set_rename(self, enabled: bool) -> None:
        pass


# server/flask_server.py
from __future__ import annotations

"""Small Flask server to remotely trigger scraping jobs.

The module exposes :class:`FlaskBridgeServer` which wraps a Flask
application and provides a thread based HTTP server.  The endpoints are
minimal and secured through an API key passed in the ``X-API-KEY``
header.  Jobs are executed in a :class:`~concurrent.futures.ThreadPoolExecutor`
so the UI remains responsive.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, Optional
import datetime as _dt
import os
import threading
import time
import uuid
import logging
from pathlib import Path

from flask import Flask, request, jsonify
from werkzeug.serving import make_server
from concurrent.futures import ThreadPoolExecutor, Future

from ..image_scraper import scrape_images, scrape_variants
from ..profile_manager import load_profiles
from ..history import load_history


log = logging.getLogger("flask-bridge")
log.setLevel(logging.INFO)


@dataclass
class JobStatus:
    """Represents the state of a running scraping job."""

    job_id: str
    status: str = "queued"   # queued|running|done|error
    progress: Dict[str, int] = field(
        default_factory=lambda: {"found": 0, "downloaded": 0, "failed": 0}
    )
    output_dir: str = ""
    started_at: Optional[str] = None
    finished_at: Optional[str] = None
    variants: Dict[str, str] = field(default_factory=dict)
    sample_images: list[str] = field(default_factory=list)
    errors: list[Dict[str, str]] = field(default_factory=list)
    message: str = ""


class JobManager:
    """Simple registry for running scraping jobs."""

    def __init__(self, max_workers: int = 2) -> None:
        self.jobs: Dict[str, JobStatus] = {}
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.lock = threading.Lock()

    def submit(self, fn, *args, **kwargs) -> JobStatus:
        job_id = uuid.uuid4().hex[:12]
        st = JobStatus(job_id=job_id)
        with self.lock:
            self.jobs[job_id] = st
        self.executor.submit(fn, st, *args, **kwargs)
        return st


class StoppableWSGIServer(threading.Thread):
    """Wrapper around Werkzeug's WSGI server allowing clean shutdown."""

    def __init__(self, app: Flask, host: str, port: int) -> None:
        super().__init__(daemon=True)
        self.srv = make_server(host, port, app)
        self.ctx = app.app_context()
        self.ctx.push()

    def run(self) -> None:  # pragma: no cover - simple thread runner
        self.srv.serve_forever()

    def shutdown(self) -> None:
        self.srv.shutdown()
        self.ctx.pop()


class FlaskBridgeServer:
    """Expose scraping helpers through a small Flask application."""

    def __init__(self, on_log=None) -> None:
        self.on_log = on_log
        self.app = Flask(__name__)
        self._server: Optional[StoppableWSGIServer] = None
        self._ngrok_tunnel = None
        self.public_url = ""
        self.api_key = os.getenv("SCRAPER_API_KEY", "")
        self.default_flags = {
            "headless": True,
            "ignore_robots": False,
            "rate_limit": 0,
            "max_workers": 1,
        }
        self.jobs = JobManager(max_workers=2)
        self._mount_routes()

    # ------------------------------------------------------------------
    # helpers
    def _log(self, msg: str) -> None:
        log.info(msg)
        if self.on_log:
            self.on_log(msg)

    # ------------------------------------------------------------------
    # Flask routes
    def _mount_routes(self) -> None:
        app = self.app

        @app.get("/health")
        def health() -> Any:
            return jsonify(
                {
                    "ok": True,
                    "version": "1.0",
                    "time": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                }
            )

        def require_key():
            key = request.headers.get("X-API-KEY", "")
            if not self.api_key or key != self.api_key:
                return jsonify({"error": "unauthorized"}), 401
            return None

        @app.post("/scrape")
        def scrape() -> Any:
            auth = require_key()
            if auth:
                return auth
            data = request.get_json(force=True, silent=True) or {}
            url = data.get("url")
            selector = data.get("selector")
            if not url or not selector:
                return (
                    jsonify({"error": "invalid_request", "detail": "url & selector required"}),
                    400,
                )
            folder = data.get("folder") or "images"
            opts = {**self.default_flags, **(data.get("options") or {})}
            st = self.jobs.submit(self._run_scrape_job, url, selector, folder, opts)
            self._log(f"Job {st.job_id} accept√© pour {url}")
            return jsonify({"job_id": st.job_id, "message": "accepted"}), 202

        @app.get("/jobs/<job_id>")
        def job_status(job_id: str) -> Any:
            auth = require_key()
            if auth:
                return auth
            st = self.jobs.jobs.get(job_id)
            if not st:
                return jsonify({"error": "not_found"}), 404
            return jsonify(st.__dict__)

        @app.get("/jobs")
        def list_jobs() -> Any:
            auth = require_key()
            if auth:
                return auth
            return jsonify([j.__dict__ for j in self.jobs.jobs.values()])

        @app.get("/profiles")
        def profiles() -> Any:
            auth = require_key()
            if auth:
                return auth
            profs = load_profiles()
            out = [
                {"name": p.get("name", ""), "selector": p.get("selector", "")}
                for p in profs
            ]
            out.sort(key=lambda p: p["name"])
            return jsonify(out), 200

        @app.post("/profiles")
        def add_profile_route() -> Any:
            auth = require_key()
            if auth:
                return auth
            data = request.get_json(force=True, silent=True) or {}
            name = (data.get("name") or "").strip()
            selector = (data.get("selector") or "").strip()
            if not name or not selector:
                return (
                    jsonify(
                        {
                            "error": "invalid_request",
                            "detail": "name and selector required",
                        }
                    ),
                    400,
                )
            try:
                from .. import profile_manager as pm

                pm.add_profile(name, selector)
            except ValueError:
                return jsonify({"error": "exists"}), 409

            try:
                from PySide6.QtCore import QMetaObject, Qt
                from ..bus.event_bus import bus

                QMetaObject.invokeMethod(bus, "profiles_changed", Qt.QueuedConnection)
            except Exception as e:  # pragma: no cover - best effort
                log.warning("Impossible d'√©mettre profiles_changed: %s", e)

            self._log(f"Profil '{name}' ajout√©")
            log.info("Profil ajout√©: %s -> %s", name, selector)
            return jsonify({"name": name, "selector": selector}), 201

        @app.get("/history")
        def hist() -> Any:
            auth = require_key()
            if auth:
                return auth
            return jsonify(load_history())

        @app.get("/debug/ping")
        def debug_ping() -> Any:
            auth = require_key()
            if auth:
                return auth
            from PySide6.QtCore import QCoreApplication

            return jsonify(
                {
                    "thread": "flask",
                    "qt_alive": QCoreApplication.instance() is not None,
                }
            )

    # ------------------------------------------------------------------
    # job execution
    def _run_scrape_job(
        self,
        st: JobStatus,
        url: str,
        selector: str,
        folder: str,
        opts: Dict[str, Any],
    ) -> None:
        st.status = "running"
        st.started_at = _dt.datetime.utcnow().isoformat() + "Z"
        try:
            if opts.get("with_variants"):
                total, driver = scrape_images(
                    url,
                    selector,
                    folder,
                    keep_driver=True,
                )
                st.variants = scrape_variants(driver)
                driver.quit()
            else:
                total = scrape_images(url, selector, folder)
            st.progress["found"] = total
            st.progress["downloaded"] = total
            st.output_dir = folder
            images_dir = Path(folder)
            if images_dir.exists():
                files = sorted(images_dir.glob("*"))[:5]
                st.sample_images = [f.name for f in files]
            st.status = "done"
        except Exception as exc:  # pragma: no cover - hard to trigger in tests
            st.status = "error"
            st.message = str(exc)
            st.errors.append({"url": url, "error": str(exc)})
        finally:
            st.finished_at = _dt.datetime.utcnow().isoformat() + "Z"

    # ------------------------------------------------------------------
    # public API
    def start(
        self,
        port: int,
        api_key: str,
        *,
        headless_default: bool,
        user_agent: str | None,
        ignore_robots_default: bool,
        rate_limit: int,
        max_workers: int,
    ) -> None:
        """Start the HTTP server."""

        self.api_key = api_key or self.api_key
        self.default_flags.update(
            {
                "headless": headless_default,
                "user_agent": user_agent,
                "ignore_robots": ignore_robots_default,
                "rate_limit": rate_limit,
                "max_workers": max_workers,
            }
        )
        self.jobs = JobManager(max_workers=max_workers)
        self._server = StoppableWSGIServer(self.app, "0.0.0.0", port)
        self._server.start()
        self._log(f"Serveur lanc√© sur le port {port}")

    def stop(self) -> None:
        """Stop the HTTP server and any active ngrok tunnel."""

        if self._server:
            self._server.shutdown()
            self._server = None
            self._log("Serveur arr√™t√©")
        self.disable_ngrok()

    def enable_ngrok(self, authtoken: str, port: int) -> str:
        """Expose the local server via ngrok."""

        try:
            from pyngrok import ngrok

            if authtoken:
                ngrok.set_auth_token(authtoken)
            self._ngrok_tunnel = ngrok.connect(port, "http")
            self.public_url = self._ngrok_tunnel.public_url
            self._log(f"Ngrok expos√© sur {self.public_url}")
        except Exception as exc:  # pragma: no cover - requires network
            self._log(f"Erreur ngrok : {exc}")
            self.public_url = ""
        return self.public_url

    def disable_ngrok(self) -> None:
        """Close the ngrok tunnel if opened."""

        try:
            if self._ngrok_tunnel:
                from pyngrok import ngrok

                ngrok.disconnect(self._ngrok_tunnel.public_url)
                ngrok.kill()
                self._log("Ngrok arr√™t√©")
        except Exception:  # pragma: no cover - best effort
            pass
        finally:
            self._ngrok_tunnel = None
            self.public_url = ""

    def is_running(self) -> bool:
        """Return ``True`` if the server is currently running."""

        return self._server is not None
