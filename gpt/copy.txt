Ce fichier regroupe le code principal du module de scraping d'images ainsi que ses compléments.

# image_scraper.py
import os
import re
import time
from pathlib import Path
from typing import List, Set

import requests
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By

DEFAULT_USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/124.0.0.0 Safari/537.36"
)


def _create_driver(user_agent: str = DEFAULT_USER_AGENT) -> webdriver.Chrome:
    options = Options()
    options.add_argument(f"--user-agent={user_agent}")
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    options.add_experimental_option("useAutomationExtension", False)
    driver = webdriver.Chrome(options=options)
    driver.execute_cdp_cmd(
        "Page.addScriptToEvaluateOnNewDocument",
        {
            "source": "Object.defineProperty(navigator, 'webdriver', {get: () => undefined});"
        },
    )
    return driver


def _scroll_page(driver: webdriver.Chrome, pause: float = 0.5) -> None:
    last_height = driver.execute_script("return document.body.scrollHeight")
    position = 0
    while position < last_height:
        position += 600
        driver.execute_script(f"window.scrollTo(0, {position});")
        time.sleep(pause)
        last_height = driver.execute_script("return document.body.scrollHeight")


def _extract_urls(driver: webdriver.Chrome, selector: str) -> List[str]:
    elements = driver.find_elements(By.CSS_SELECTOR, selector)
    urls: Set[str] = set()
    for el in elements:
        src = el.get_attribute("src") or el.get_attribute("data-src")
        if src:
            urls.add(src)
            continue
        style = el.get_attribute("style") or ""
        match = re.search(r"url\(['\"]?(.*?)['\"]?\)", style)
        if match:
            urls.add(match.group(1))
    return list(urls)


def _download(url: str, folder: Path) -> None:
    if url.startswith("data:image"):
        print(f"\u26A0\uFE0F Ignoré (image base64) : {url[:50]}...")
        return
    try:
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()
    except Exception as exc:
        print(f"\u274c Erreur lors du téléchargement de {url}: {exc}")
        return

    name = os.path.basename(url.split("?")[0]) or "image"
    path = folder / name
    base, ext = os.path.splitext(path)
    idx = 1
    while path.exists():
        path = Path(f"{base}_{idx}{ext}")
        idx += 1
    with open(path, "wb") as f:
        f.write(resp.content)


def scrape_images(page_url: str, selector: str) -> int:
    print("Chargement...")
    driver = _create_driver()
    try:
        driver.get(page_url)
        _scroll_page(driver)
        urls = _extract_urls(driver, selector)
        total = len(urls)
        print(f"{total} images trouv\u00e9es")
    finally:
        driver.quit()

    images_dir = Path("images")
    images_dir.mkdir(exist_ok=True)
    for i, url in enumerate(urls, 1):
        print(f"T\u00e9l\u00e9chargement de l'image n\u00b0{i}/{total}")
        _download(url, images_dir)
    print("\u2705 Termin\u00e9")
    return total


if __name__ == "__main__":
    scrape_images("https://exemple.com/produit", ".product-image img")

# widgets/image_widget.py
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QLabel,
    QPushButton,
    QTextEdit,
    QProgressBar,
    QLineEdit,
    QFileDialog,
    QHBoxLayout,
    QComboBox,
    QApplication,
)
from PySide6.QtCore import Qt, Slot
from PySide6.QtGui import QClipboard

import sys


class _ConsoleStream:
    """File-like object writing text directly to a :class:`QTextEdit`."""

    def __init__(self, widget: QTextEdit) -> None:
        self.widget = widget

    def write(self, text: str) -> int:
        if text:
            # Qt widgets must be manipulated from the GUI thread. Using
            # ``append`` is safe enough for short text snippets.
            self.widget.append(text.rstrip())
        return len(text)

    def flush(self) -> None:  # pragma: no cover - required for file-like API
        pass

from .. import profile_manager as pm
from .. import history

from ..image_scraper import scrape_images


class ImageScraperWidget(QWidget):
    """Simple interface to run the image scraper."""

    def __init__(self) -> None:
        super().__init__()

        self.url_edit = QLineEdit()
        self.url_edit.setPlaceholderText("URL de la page")

        self.profile_combo = QComboBox()
        self.profiles: list[dict[str, str]] = []
        self.selected_selector: str = ""
        self.profile_combo.currentIndexChanged.connect(self._on_profile_changed)

        self.folder_edit = QLineEdit()
        self.folder_edit.setPlaceholderText("Dossier de destination")

        browse_btn = QPushButton("Parcourir…")
        browse_btn.clicked.connect(self._choose_folder)

        folder_layout = QHBoxLayout()
        folder_layout.addWidget(self.folder_edit)
        folder_layout.addWidget(browse_btn)

        self.start_btn = QPushButton("Lancer")
        self.start_btn.clicked.connect(self._start)
        self.copy_btn = QPushButton("Copier")
        self.copy_btn.clicked.connect(self._copy_console)

        buttons_layout = QHBoxLayout()
        buttons_layout.addWidget(self.start_btn)
        buttons_layout.addWidget(self.copy_btn)

        self.console = QTextEdit()
        self.console.setReadOnly(True)

        self.progress_bar = QProgressBar()
        self.progress_bar.hide()

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("URL:"))
        layout.addWidget(self.url_edit)
        layout.addWidget(QLabel("Profil:"))
        layout.addWidget(self.profile_combo)
        layout.addWidget(QLabel("Dossier:"))
        layout.addLayout(folder_layout)
        layout.addLayout(buttons_layout)
        layout.addWidget(self.console)
        layout.addWidget(self.progress_bar)

        self.refresh_profiles()
        last = history.load_last_used()
        self.url_edit.setText(last.get("url", ""))
        self.folder_edit.setText(last.get("folder", ""))

    # ------------------------------------------------------------------
    def _on_profile_changed(self, index: int) -> None:
        if 0 <= index < len(self.profiles):
            self.selected_selector = self.profiles[index].get("selector", "")
        else:
            self.selected_selector = ""

    def set_selected_profile(self, profile: str) -> None:
        for i, p in enumerate(self.profiles):
            if p.get("name") == profile:
                self.profile_combo.setCurrentIndex(i)
                self.selected_selector = p.get("selector", "")
                return
        self.profile_combo.setCurrentIndex(-1)
        self.selected_selector = ""

    def refresh_profiles(self) -> None:
        self.profiles = pm.load_profiles()
        current = self.profile_combo.currentText()
        self.profile_combo.clear()
        for p in self.profiles:
            self.profile_combo.addItem(p.get("name", ""))
        # restore previous selection if possible
        if current:
            self.set_selected_profile(current)
        else:
            self._on_profile_changed(self.profile_combo.currentIndex())

    @Slot()
    def _choose_folder(self) -> None:
        path = QFileDialog.getExistingDirectory(self, "Choisir un dossier")
        if path:
            self.folder_edit.setText(path)

    @Slot()
    def _copy_console(self) -> None:
        """Copy the console's contents to the clipboard."""
        text = self.console.toPlainText()
        QApplication.clipboard().setText(text, mode=QClipboard.Clipboard)
        # Also populate the selection clipboard on platforms that support it.
        QApplication.clipboard().setText(text, mode=QClipboard.Selection)

    @Slot()
    def _start(self) -> None:
        url = self.url_edit.text().strip()
        selector = self.selected_selector.strip()
        folder = self.folder_edit.text().strip() or "images"
        if not url or not selector:
            self.console.append("❌ URL ou sélecteur manquant")
            return

        self.start_btn.setEnabled(False)
        self.console.clear()
        self.progress_bar.show()
        self.progress_bar.setRange(0, 0)
        stream = _ConsoleStream(self.console)
        old_stdout = sys.stdout
        sys.stdout = stream
        try:
            total = scrape_images(url, selector)
        except Exception as exc:
            self.console.append(f"❌ Erreur: {exc}")
        else:
            self.console.append("✅ Terminé")
            history.log_scrape(url, self.profile_combo.currentText(), total, folder)
        finally:
            sys.stdout = old_stdout
            self.progress_bar.hide()
            self.start_btn.setEnabled(True)


# widgets/scrap_widget.py (partie relevante)
from PySide6.QtWidgets import QWidget, QVBoxLayout, QTabWidget

from .image_widget import ImageScraperWidget
from .history_widget import HistoryWidget


class _DummySubWidget(QWidget):
    def __init__(self) -> None:
        super().__init__()
        layout = QVBoxLayout(self)

    def set_selected_profile(self, profile: str) -> None:
        pass

    def refresh_profiles(self) -> None:
        pass


class ScrapWidget(QWidget):
    def __init__(self) -> None:
        super().__init__()
        self.modules_order = ["images", "combined", "history"]
        self.images_widget = ImageScraperWidget()
        self.combined_widget = _DummySubWidget()
        self.history_widget = HistoryWidget()
        self.tabs = QTabWidget()
        self.tabs.addTab(self.images_widget, "Images")
        self.tabs.addTab(self.combined_widget, "Combined")
        self.tabs.addTab(self.history_widget, "Historique")
        layout = QVBoxLayout(self)
        layout.addWidget(self.tabs)

    def toggle_module(self, name: str, enabled: bool) -> None:
        pass

    def set_rename(self, enabled: bool) -> None:
        pass


# Fin du fichier
